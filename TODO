//not arranged

- 0: agree over a common coding style (I'd suggest gobject/gstreamer plus gnome
     coding guidelines) as pointed here:
     http://gstreamer.freedesktop.org/data/doc/gstreamer/head/faq/html/chapter-developing.html
     cap: I am ok, but I am not using emacs, so I let you run the re-indent script

(DONE) - 1: make Filippo's GstGLEffects work on this repository. 

(DONE) - 2: use GstGLShader in the GLSL colorspace conversion.

- 3: add GLEW check in configure.ac

(DONE) - 4: make the plugin (any pipeline) properly shutdown when Shader compilation failed.
            (using "return GST_FLOW_UNEXPECTED")

(DONE) - 5: make the plugin (any pipeline) properly shutdown when one of the "check requirements" failed.
            (for example when FBO extension is not available)
            For now it properly shutdown only when using the glimagesink

(DONE) - 6: make an example named "filterxoverlay" similar to gtkxoverlay one. But use a more complex pipeline
     involving several glfilters. In order to test switching bettween gst states on it.

- 7: put the pipelines listed in tests/pipelines to an automated test that attempts to reach some states.

- 8: make two elements named "gltee" (attach as much texture (to its fbo) as tee src pads) and "glqueue".
     In order to have something like that:
     videotestsrc ! glupload ! glfilterA ! gltee name=t \
     t. ! glqueue ! glfilterB ! glimagesink \
     t. ! glqueue ! glfilterC ! glimagesink
     Assuming glfilterA is GPU consumming and so do not need to duplicate it.

- 9: rewrite the freeglut part that I minimized. Although I removed 90% of the orignal code,
     it should be rewrite with the GLib API. To have a better design and handle X/WIN32 with interfaces
     instead of having a lot of "define WIN32" scopes.
     And make it thread safe in order to have one glthread per GstGLDisplay, instead of having a global glthread.
     The tests/examples/doublecube test shows the limitation of having only one (global) glthread.
     (I am not really sure about this last remark since I made a modification in this example. Now the video speed is
     very clean, even after moving/resizing the window).

- 10: make colorspace conversion through ColorMatrix when GLSL (and mesa YCbCr) is not available and when imaging extension
      is available.

- 11: make a test to estimate how much is a colorspace conversion. I mean compare an output frame
      to reference frame and estimate the differences. (usefull to compare several implementations)

- 12: write a cmake build or an other well known opensource and multiplatform builder.

- 13: test colorspace conversion with Apple YCbCr extension.

- 14: test the plugin on MAC.

- 15: test the plugin on WIN CE and some other embedded operating system.

- 16: If it exists a tool that can automatically convert fragment_shader code to fragment_program code
      then we would be able to do some basic stuffs as colorspace conversion even if GLSL is not available.
      (And so have some more cool stuffs work on Intel card for example)
      cg can convert GLSL code to ARB_fp/ARB_vp.
